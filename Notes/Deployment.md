# Deployment Notes

1. Create a Dockerfile with all the necessary info. Important point to remember about EXPOSE port it, it doesn't really exposes the port, but just serves as a documentation purpose between the builder and the deployer.
2. Once the docker file is setup, we will use the command `docker build -t bankoindiana:latest .` to build the app, supplying a tag using the -t argument. Once the build is done, you can check the built images by running `docker images`.
3. A multistage docker file is used to just copy the binary to the image, thereby massively reducing the size.
4. To run the build image we will use the command `docker run --name bankoindiana -p 8080:8080 bankoindiana:latest` This will initially fail, as we have not copied the app.env file. A failed run will also leave a container trace, we can check that using `docker ps -a` command. To remove it we use `docker rm bankoindiana`
5. Before building the new image need to remove the current one. And then build the new one. 
6. To run the image in production mode, just add the -e flag to supply environment config, like `docker run --name bankoindiana -p 8080:8080 -e GIN_MODE=release bankoindiana:latest`. We can use the flag `--network` to specify a network to run this container connected to.
7. On doing this, the server will start but when we send any request the connection will be refused. This is cause in the app.env file we are connecting to the DB using the localhost, however that is not the case as both app and db are 2 separate containers with their own network config. To verify this use `docker container inspect <name-of-container>` and check the network config there. We will notice that both have different IP addresses.
8. To check docker network information we can use `docker network ls` and `docker network inspect <bridge-name>`.
9. Docker compose is used to start multiple services from one command. All config can be done in that file. Documentation is availble on the `docs.docker.com` site.
10. Once the docker compose file is created we can run it using the command, `docker compose up`. To remove all containers and networks we do `docker compose down`. Note this will not clear the images, and that will need to be done manually. For this we can use the command `docker rmi <id of container/network>`
11. When we try to run the multiple services using the docker compose file, they will try starting at the same time. If the api and the db are related to each other, it will fail, as the api will try to migrate and the db would not be up yet. Hence for this we use the `wait-for.sh` script to sync containers startup.
12. To supply DB source with DB container's network ID we pass the DB source in the environment `docker run --name bankoindiana -p 8080:8080 -e GIN_MODE=release -e DB_SOURCE="postgresql://root:something_secret@172.17.0.3:5432/bankoindiana?sslmode=disable" bankoindiana:latest`.
13. Most of the time in case of any errors, like evans not starting up, or API failing due to connection error, its mainly due to the api and the postgres running on different docker networks. The issue with bridge network is, that containers can't find each other by names, which is not the case with custom networks. 